// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countCategories = `-- name: CountCategories :one

SELECT COUNT(*) FROM categories WHERE deleted_at IS NULL
`

// Categories
func (q *Queries) CountCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEpisodesBySeries = `-- name: CountEpisodesBySeries :one

SELECT COUNT(*) FROM episodes
WHERE series_id = $1 AND deleted_at IS NULL
`

// Episodes
func (q *Queries) CountEpisodesBySeries(ctx context.Context, seriesID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEpisodesBySeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one

SELECT COUNT(*) FROM series WHERE deleted_at IS NULL
`

// Series
func (q *Queries) CountSeries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSeries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAsset = `-- name: CreateAsset :one
INSERT INTO episode_assets (
    episode_id, asset_type, mime_type, size_bytes, url, storage
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, episode_id, asset_type, mime_type, size_bytes, url, storage, created_at
`

type CreateAssetParams struct {
	EpisodeID uuid.UUID `json:"episode_id"`
	AssetType string    `json:"asset_type"`
	MimeType  string    `json:"mime_type"`
	SizeBytes *int64    `json:"size_bytes"`
	Url       *string   `json:"url"`
	Storage   []byte    `json:"storage"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (EpisodeAsset, error) {
	row := q.db.QueryRow(ctx, createAsset,
		arg.EpisodeID,
		arg.AssetType,
		arg.MimeType,
		arg.SizeBytes,
		arg.Url,
		arg.Storage,
	)
	var i EpisodeAsset
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.AssetType,
		&i.MimeType,
		&i.SizeBytes,
		&i.Url,
		&i.Storage,
		&i.CreatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (slug)
VALUES ($1)
RETURNING id, slug, created_at, updated_at, deleted_at
`

func (q *Queries) CreateCategory(ctx context.Context, slug string) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory, slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
    series_id, title, description,
    duration_seconds, publish_date
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, series_id, title, description, duration_seconds, publish_date, created_at, updated_at, deleted_at
`

type CreateEpisodeParams struct {
	SeriesID        uuid.UUID  `json:"series_id"`
	Title           string     `json:"title"`
	Description     *string    `json:"description"`
	DurationSeconds *int32     `json:"duration_seconds"`
	PublishDate     *time.Time `json:"publish_date"`
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, createEpisode,
		arg.SeriesID,
		arg.Title,
		arg.Description,
		arg.DurationSeconds,
		arg.PublishDate,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Title,
		&i.Description,
		&i.DurationSeconds,
		&i.PublishDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (title, description, category_id, language, series_type)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, title, description, category_id, language, series_type, created_at, updated_at, deleted_at
`

type CreateSeriesParams struct {
	Title       string    `json:"title"`
	Description *string   `json:"description"`
	CategoryID  uuid.UUID `json:"category_id"`
	Language    *string   `json:"language"`
	SeriesType  string    `json:"series_type"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, createSeries,
		arg.Title,
		arg.Description,
		arg.CategoryID,
		arg.Language,
		arg.SeriesType,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CategoryID,
		&i.Language,
		&i.SeriesType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteAsset = `-- name: DeleteAsset :exec
DELETE FROM episode_assets
WHERE id = $1
`

func (q *Queries) DeleteAsset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAsset, id)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
UPDATE categories
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
UPDATE episodes
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeleteEpisode(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEpisode, id)
	return err
}

const deleteSeries = `-- name: DeleteSeries :exec
UPDATE series
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeleteSeries(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSeries, id)
	return err
}

const getAsset = `-- name: GetAsset :one
SELECT id, episode_id, asset_type, mime_type, size_bytes, url, storage, created_at FROM episode_assets
WHERE id = $1
`

func (q *Queries) GetAsset(ctx context.Context, id uuid.UUID) (EpisodeAsset, error) {
	row := q.db.QueryRow(ctx, getAsset, id)
	var i EpisodeAsset
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.AssetType,
		&i.MimeType,
		&i.SizeBytes,
		&i.Url,
		&i.Storage,
		&i.CreatedAt,
	)
	return i, err
}

const getCategory = `-- name: GetCategory :one
SELECT id, slug, created_at, updated_at, deleted_at FROM categories
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetCategory(ctx context.Context, id uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEpisode = `-- name: GetEpisode :one
SELECT id, series_id, title, description, duration_seconds, publish_date, created_at, updated_at, deleted_at FROM episodes
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetEpisode(ctx context.Context, id uuid.UUID) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Title,
		&i.Description,
		&i.DurationSeconds,
		&i.PublishDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEpisodeWithAssets = `-- name: GetEpisodeWithAssets :many
SELECT 
    e.id               AS episode_id,
    e.series_id,
    e.title,
    e.description,
    e.duration_seconds,
    e.publish_date,
    e.created_at       AS episode_created_at,
    e.updated_at       AS episode_updated_at,
    a.id               AS asset_id,
    a.asset_type,
    a.mime_type,
    a.size_bytes,
    a.url,
    a.storage,
    a.created_at       AS asset_created_at
FROM episodes e
LEFT JOIN episode_assets a ON e.id = a.episode_id
WHERE e.id = $1 AND e.deleted_at IS NULL
`

type GetEpisodeWithAssetsRow struct {
	EpisodeID        uuid.UUID  `json:"episode_id"`
	SeriesID         uuid.UUID  `json:"series_id"`
	Title            string     `json:"title"`
	Description      *string    `json:"description"`
	DurationSeconds  *int32     `json:"duration_seconds"`
	PublishDate      *time.Time `json:"publish_date"`
	EpisodeCreatedAt time.Time  `json:"episode_created_at"`
	EpisodeUpdatedAt time.Time  `json:"episode_updated_at"`
	AssetID          *uuid.UUID `json:"asset_id"`
	AssetType        *string    `json:"asset_type"`
	MimeType         *string    `json:"mime_type"`
	SizeBytes        *int64     `json:"size_bytes"`
	Url              *string    `json:"url"`
	Storage          []byte     `json:"storage"`
	AssetCreatedAt   *time.Time `json:"asset_created_at"`
}

func (q *Queries) GetEpisodeWithAssets(ctx context.Context, id uuid.UUID) ([]GetEpisodeWithAssetsRow, error) {
	rows, err := q.db.Query(ctx, getEpisodeWithAssets, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEpisodeWithAssetsRow{}
	for rows.Next() {
		var i GetEpisodeWithAssetsRow
		if err := rows.Scan(
			&i.EpisodeID,
			&i.SeriesID,
			&i.Title,
			&i.Description,
			&i.DurationSeconds,
			&i.PublishDate,
			&i.EpisodeCreatedAt,
			&i.EpisodeUpdatedAt,
			&i.AssetID,
			&i.AssetType,
			&i.MimeType,
			&i.SizeBytes,
			&i.Url,
			&i.Storage,
			&i.AssetCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeries = `-- name: GetSeries :one
SELECT id, title, description, category_id, language, series_type, created_at, updated_at, deleted_at FROM series
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetSeries(ctx context.Context, id uuid.UUID) (Series, error) {
	row := q.db.QueryRow(ctx, getSeries, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CategoryID,
		&i.Language,
		&i.SeriesType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listAssetsByEpisode = `-- name: ListAssetsByEpisode :many

SELECT id, episode_id, asset_type, mime_type, size_bytes, url, storage, created_at FROM episode_assets
WHERE episode_id = $1
`

// Episode Assets
func (q *Queries) ListAssetsByEpisode(ctx context.Context, episodeID uuid.UUID) ([]EpisodeAsset, error) {
	rows, err := q.db.Query(ctx, listAssetsByEpisode, episodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EpisodeAsset{}
	for rows.Next() {
		var i EpisodeAsset
		if err := rows.Scan(
			&i.ID,
			&i.EpisodeID,
			&i.AssetType,
			&i.MimeType,
			&i.SizeBytes,
			&i.Url,
			&i.Storage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT id, slug, created_at, updated_at, deleted_at FROM categories
WHERE deleted_at IS NULL
ORDER BY updated_at
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoriesPaginated = `-- name: ListCategoriesPaginated :many
SELECT id, slug, created_at, updated_at, deleted_at
FROM categories
WHERE deleted_at IS NULL
ORDER BY updated_at
LIMIT $1 OFFSET $2
`

type ListCategoriesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCategoriesPaginated(ctx context.Context, arg ListCategoriesPaginatedParams) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategoriesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeries = `-- name: ListEpisodesBySeries :many
SELECT id, series_id, title, description, duration_seconds, publish_date, created_at, updated_at, deleted_at FROM episodes
WHERE series_id = $1
  AND deleted_at IS NULL
ORDER BY publish_date DESC
`

func (q *Queries) ListEpisodesBySeries(ctx context.Context, seriesID uuid.UUID) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeries, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.Title,
			&i.Description,
			&i.DurationSeconds,
			&i.PublishDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesBySeriesPaginated = `-- name: ListEpisodesBySeriesPaginated :many
SELECT id, series_id, title, description, duration_seconds,
       publish_date, created_at, updated_at, deleted_at
FROM episodes
WHERE series_id = $1 AND deleted_at IS NULL
ORDER BY publish_date DESC
LIMIT $2 OFFSET $3
`

type ListEpisodesBySeriesPaginatedParams struct {
	SeriesID uuid.UUID `json:"series_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListEpisodesBySeriesPaginated(ctx context.Context, arg ListEpisodesBySeriesPaginatedParams) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesBySeriesPaginated, arg.SeriesID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.SeriesID,
			&i.Title,
			&i.Description,
			&i.DurationSeconds,
			&i.PublishDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesWithAssetsBySeriesPaginated = `-- name: ListEpisodesWithAssetsBySeriesPaginated :many
SELECT
    e.id AS episode_id,
    e.series_id,
    e.title,
    e.description,
    e.duration_seconds,
    e.publish_date,
    e.created_at AS episode_created_at,
    e.updated_at AS episode_updated_at,
    a.id AS asset_id,
    a.asset_type,
    a.mime_type,
    a.size_bytes,
    a.url,
    a.storage,
    a.created_at AS asset_created_at
FROM
    episodes e
LEFT JOIN
    episode_assets a ON e.id = a.episode_id
WHERE
    e.series_id = $1 AND e.deleted_at IS NULL
ORDER BY
    e.publish_date DESC
LIMIT $2 OFFSET $3
`

type ListEpisodesWithAssetsBySeriesPaginatedParams struct {
	SeriesID uuid.UUID `json:"series_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListEpisodesWithAssetsBySeriesPaginatedRow struct {
	EpisodeID        uuid.UUID  `json:"episode_id"`
	SeriesID         uuid.UUID  `json:"series_id"`
	Title            string     `json:"title"`
	Description      *string    `json:"description"`
	DurationSeconds  *int32     `json:"duration_seconds"`
	PublishDate      *time.Time `json:"publish_date"`
	EpisodeCreatedAt time.Time  `json:"episode_created_at"`
	EpisodeUpdatedAt time.Time  `json:"episode_updated_at"`
	AssetID          *uuid.UUID `json:"asset_id"`
	AssetType        *string    `json:"asset_type"`
	MimeType         *string    `json:"mime_type"`
	SizeBytes        *int64     `json:"size_bytes"`
	Url              *string    `json:"url"`
	Storage          []byte     `json:"storage"`
	AssetCreatedAt   *time.Time `json:"asset_created_at"`
}

func (q *Queries) ListEpisodesWithAssetsBySeriesPaginated(ctx context.Context, arg ListEpisodesWithAssetsBySeriesPaginatedParams) ([]ListEpisodesWithAssetsBySeriesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listEpisodesWithAssetsBySeriesPaginated, arg.SeriesID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEpisodesWithAssetsBySeriesPaginatedRow{}
	for rows.Next() {
		var i ListEpisodesWithAssetsBySeriesPaginatedRow
		if err := rows.Scan(
			&i.EpisodeID,
			&i.SeriesID,
			&i.Title,
			&i.Description,
			&i.DurationSeconds,
			&i.PublishDate,
			&i.EpisodeCreatedAt,
			&i.EpisodeUpdatedAt,
			&i.AssetID,
			&i.AssetType,
			&i.MimeType,
			&i.SizeBytes,
			&i.Url,
			&i.Storage,
			&i.AssetCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeries = `-- name: ListSeries :many
SELECT id, title, description, category_id, language, series_type, created_at, updated_at, deleted_at FROM series
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListSeries(ctx context.Context) ([]Series, error) {
	rows, err := q.db.Query(ctx, listSeries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CategoryID,
			&i.Language,
			&i.SeriesType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeriesPaginated = `-- name: ListSeriesPaginated :many
SELECT id, title, description, category_id, language, series_type,
       created_at, updated_at, deleted_at 
FROM series
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListSeriesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSeriesPaginated(ctx context.Context, arg ListSeriesPaginatedParams) ([]Series, error) {
	rows, err := q.db.Query(ctx, listSeriesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Series{}
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CategoryID,
			&i.Language,
			&i.SeriesType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAsset = `-- name: UpdateAsset :one
UPDATE episode_assets
SET mime_type = $2,
    size_bytes = $3,
    url = $4,
    storage = $5
WHERE id = $1
RETURNING id, episode_id, asset_type, mime_type, size_bytes, url, storage, created_at
`

type UpdateAssetParams struct {
	ID        uuid.UUID `json:"id"`
	MimeType  string    `json:"mime_type"`
	SizeBytes *int64    `json:"size_bytes"`
	Url       *string   `json:"url"`
	Storage   []byte    `json:"storage"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (EpisodeAsset, error) {
	row := q.db.QueryRow(ctx, updateAsset,
		arg.ID,
		arg.MimeType,
		arg.SizeBytes,
		arg.Url,
		arg.Storage,
	)
	var i EpisodeAsset
	err := row.Scan(
		&i.ID,
		&i.EpisodeID,
		&i.AssetType,
		&i.MimeType,
		&i.SizeBytes,
		&i.Url,
		&i.Storage,
		&i.CreatedAt,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET slug = $2,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
RETURNING id, slug, created_at, updated_at, deleted_at
`

type UpdateCategoryParams struct {
	ID   uuid.UUID `json:"id"`
	Slug string    `json:"slug"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory, arg.ID, arg.Slug)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes
SET title = $2,
    description = $3,
    duration_seconds = $4,
    publish_date = $5,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
RETURNING id, series_id, title, description, duration_seconds, publish_date, created_at, updated_at, deleted_at
`

type UpdateEpisodeParams struct {
	ID              uuid.UUID  `json:"id"`
	Title           string     `json:"title"`
	Description     *string    `json:"description"`
	DurationSeconds *int32     `json:"duration_seconds"`
	PublishDate     *time.Time `json:"publish_date"`
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, updateEpisode,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.DurationSeconds,
		arg.PublishDate,
	)
	var i Episode
	err := row.Scan(
		&i.ID,
		&i.SeriesID,
		&i.Title,
		&i.Description,
		&i.DurationSeconds,
		&i.PublishDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE series
SET title = $2,
    description = $3,
    category_id = $4,
    language = $5,
    series_type = $6,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
RETURNING id, title, description, category_id, language, series_type, created_at, updated_at, deleted_at
`

type UpdateSeriesParams struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	Description *string   `json:"description"`
	CategoryID  uuid.UUID `json:"category_id"`
	Language    *string   `json:"language"`
	SeriesType  string    `json:"series_type"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, updateSeries,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.CategoryID,
		arg.Language,
		arg.SeriesType,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CategoryID,
		&i.Language,
		&i.SeriesType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
